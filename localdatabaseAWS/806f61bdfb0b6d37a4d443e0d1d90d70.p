(dp0
Vhead
p1
(dp2
Vlink
p3
(lp4
sVvars
p5
(lp6
Vp
p7
aVo
p8
assVresults
p9
(dp10
Vdistinct
p11
I00
sVbindings
p12
(lp13
(dp14
g7
(dp15
Vtype
p16
Vuri
p17
sVvalue
p18
Vhttp://dbpedia.org/ontology/abstract
p19
ssg8
(dp20
Vxml:lang
p21
Ven
p22
sVtype
p23
Vliteral
p24
sVvalue
p25
VIn software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop ("spin") while repeatedly checking if the lock is available. Since the thread remains active but is not performing a useful task, the use of such a lock is a kind of busy waiting. Once acquired, spinlocks will usually be held until they are explicitly released, although in some implementations they may be automatically released if the thread being waited on (that which holds the lock) blocks, or "goes to sleep".Because they avoid overhead from operating system process rescheduling or context switching, spinlocks are efficient if threads are likely to be blocked for only short periods. For this reason, operating-system kernels often use spinlocks. However, spinlocks become wasteful if held for longer durations, as they may prevent other threads from running and require rescheduling. The longer a thread holds a lock, the greater the risk that the thread will be interrupted by the OS scheduler while holding the lock. If this happens, other threads will be left "spinning" (repeatedly trying to acquire the lock), while the thread holding the lock is not making progress towards releasing it. The result is an indefinite postponement until the thread holding the lock can finish and release it. This is especially true on a single-processor system, where each waiting thread of the same priority is likely to waste its quantum (allocated time where a thread can run) spinning until the thread that holds the lock is finally finished.Implementing spin locks correctly offers challenges because programmers must take into account the possibility of simultaneous access to the lock, which could cause race conditions. Generally, such implementation is possible only with special assembly-language instructions, such as atomic test-and-set operations, and cannot be easily implemented in programming languages not supporting truly atomic operations. On architectures without such operations, or if high-level language implementation is required, a non-atomic locking algorithm may be used, e.g. Peterson's algorithm. But note that such an implementation may require more memory than a spinlock, be slower to allow progress after unlocking, and may not be implementable in a high-level language if out-of-order execution is allowed.
p26
ssa(dp27
g7
(dp28
Vtype
p29
Vuri
p30
sVvalue
p31
Vhttp://dbpedia.org/ontology/wikiPageExtracted
p32
ssg8
(dp33
Vdatatype
p34
Vhttp://www.w3.org/2001/XMLSchema#dateTime
p35
sVtype
p36
Vtyped-literal
p37
sVvalue
p38
V2016-11-06T05:17:13Z
p39
ssa(dp40
g7
(dp41
Vtype
p42
Vuri
p43
sVvalue
p44
Vhttp://dbpedia.org/ontology/wikiPageLength
p45
ssg8
(dp46
Vdatatype
p47
Vhttp://www.w3.org/2001/XMLSchema#nonNegativeInteger
p48
sVtype
p49
Vtyped-literal
p50
sVvalue
p51
V9959
p52
ssa(dp53
g7
(dp54
Vtype
p55
Vuri
p56
sVvalue
p57
Vhttp://dbpedia.org/ontology/wikiPageModified
p58
ssg8
(dp59
Vdatatype
p60
Vhttp://www.w3.org/2001/XMLSchema#dateTime
p61
sVtype
p62
Vtyped-literal
p63
sVvalue
p64
V2016-07-21T22:36:45Z
p65
ssa(dp66
g7
(dp67
Vtype
p68
Vuri
p69
sVvalue
p70
Vhttp://dbpedia.org/ontology/wikiPageOutDegree
p71
ssg8
(dp72
Vdatatype
p73
Vhttp://www.w3.org/2001/XMLSchema#nonNegativeInteger
p74
sVtype
p75
Vtyped-literal
p76
sVvalue
p77
V56
p78
ssasVordered
p79
I01
ss.